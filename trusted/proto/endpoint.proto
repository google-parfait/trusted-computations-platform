syntax = "proto3";
package endpoint;

// Envelope for the messages coming from the Untrusted Launcher to the Trusted
// Host.
message EnvelopeIn {
  oneof msg {
    // Requests the Trusted Host to start a new Raft node. Must be the first
    // message sent by the Untrusted Launcher to the Trusted Host.
    StartNodeRequest start_node = 1;
    // Requests the Trusted Host to stop an already running Raft node. Must be
    // the last message sent by the Untrusted Launcher to the Trusted
    // Host.
    StopNodeRequest stop_node = 2;
    // Requests the Trusted Host to issue a command to change Raft cluster that
    // is led by the node.
    ChangeClusterRequest change_cluster = 3;
    // Requests the Trusted Host to report the current state of the Raft
    // cluster, including which node is the leader, which nodes are in the
    // cluster, are there any pending cluster changes. The latter is important
    // to enable cluster membership changes which must be carried out one at a
    // time.
    CheckClusterRequest check_cluster = 4;
    // Requests the Trusted Host to deliver a Raft message to the node.
    DeliverMessage deliver_message = 5;
    // Requests the Trusted Host to execute a proposal representing a client
    // action or a query. Note that it is up to the application to interpret and
    // execute that proposal.
    ExecuteProposalRequest execute_proposal = 6;
  }
}

// Envelope for the messages coming from the Trusted Host to the Untrusted
// Launcher. The Untrusted Launcher is then responsible for delivery of the
// messages to the intended recipients.
message EnvelopeOut {
  oneof msg {
    // Responds to the Untrusted Launcher with the started node idenity and
    // indication status. The generated node identity will be used to route
    // messages between nodes.
    StartNodeResponse start_node = 1;
    // Responds to the Untrsuted Launcher with the stop node result.
    StopNodeResponse stop_node = 2;
    // Requests the Untrusted Launcher to log given message for troubleshooting.
    LogMessage log = 3;
    // Responds to the Untrusted Launcher with the indication if the requested
    // Raft cluster change has been accepted for processing. Note that the
    // actual execution will take time due to replication. The Untrusted
    // Launcher can poll for the result by requesting cluster check.
    ChangeClusterResponse change_cluster = 4;
    // Responds to the Untrusted Launcher with the state of the cluster. The
    // response may be sent because it was explicitly requested or because the
    // internal state of the Raft node has changed.
    CheckClusterResponse check_cluster = 5;
    // Requests the Untrusted Launcher to deliver the Raft message to a Raft
    // node hosted in a different Trusted Host.
    DeliverMessage deliver_message = 6;
    // Responds to the Untrusted Launcher with the proposal result in case of
    // success or an error (for example, the node which received the proposal is
    // not the leader). Note that it may take some time for the Trusted
    // Application to respond to the proposal (the execution of a proposal
    // requires it to be committed to the replicated log). Also it is possible
    // that the node that has accepted the proposal and the node that has
    // responded to the proposal are not the same node due failures.
    ExecuteProposalResponse execute_proposal = 7;
  }
}

message StartNodeRequest {
  // Inidicates if the new Raft node to be started as the leader of the Raft
  // cluster.
  bool is_leader = 1;
  // If set is used as the started node id. Must only be used for testing
  // purposes.
  uint64 node_id_hint = 2;
}

message StartNodeResponse {
  // Started node id, generated by the node or set to the provided in the
  // request id.
  uint64 node_id = 1;
}

message StopNodeRequest {}

message StopNodeResponse {}

message LogMessage {
  // Holds severity of the message.
  LogSeverity severity = 1;
  // Holds message to be logged for troubleshooting.
  string message = 2;
}

enum LogSeverity {
  LOG_SEVERITY_UNSPECIFIED = 0;
  LOG_SEVERITY_INFO = 1;
  LOG_SEVERITY_WARNING = 2;
  LOG_SEVERITY_ERROR = 3;
  LOG_SEVERITY_CRITICAL = 4;
  LOG_SEVERITY_DEBUG = 5;
  LOG_SEVERITY_TRACE = 6;
}

message ChangeClusterRequest {
  // Holds unique id that identifies the Raft cluster change.
  uint64 change_id = 1;
  // Holds id of the node to be either added or removed from the Raft cluster.
  uint64 node_id = 2;
  // Inidicates whether the node must be added or removed.
  ChangeClusterType change_type = 3;
}

message ChangeClusterResponse {
  uint64 change_id = 1;
  // Indicates if the Raft cluster change has been accepted or
  ChangeClusterStatus change_status = 2;
}

enum ChangeClusterType {
  CHANGE_TYPE_UNSPECIFIED = 0;
  // Requests to add node to the Raft cluster.
  CHANGE_TYPE_ADD_NODE = 1;
  // Requests to remove node from the Raft cluster.
  CHANGE_TYPE_REMOVE_NODE = 2;
}

enum ChangeClusterStatus {
  CHANGE_STATUS_UNSPECIFIED = 0;
  // Indicates that the Raft cluster change has been accepted for processing.
  CHANGE_STATUS_PENDING = 1;
  // Indicates that the Raft cluster change has been rejected which can be
  // either because the node is not a leader or there is already a pending
  // cluster change.
  CHANGE_STATUS_REJECTED = 2;
}

message CheckClusterRequest {}

message CheckClusterResponse {
  // Holds the id of the Raft node currently elected leader. Set to 0 if the
  // leader is not known.
  uint64 leader_node_id = 1;
  // Holds the term of the leader. Set to 0 if leader is not known.
  uint64 leader_term = 2;
  // Holds the set of node ids that currently belong to the cluster.
  repeated uint64 cluster_node_ids = 3;
  // Indicates if there are any pending cluster changes.
  bool has_pending_changes = 4;
}

message DeliverMessage {
  // Holds the id of the recipient node.
  uint64 recipient_node_id = 1;
  // Holds the id of the sender node.
  uint64 sender_node_id = 2;
  // Holds a potentially encrypted contents of the message to be delivered.
  bytes message_contents = 3;
}

message ExecuteProposalRequest {
  // Holds serialized proposal contents. It is up to the Trusted Application to
  // interpret it.
  bytes proposal_contents = 2;
}

message ExecuteProposalResponse {
  // Holds serialized proposal response. It is up to the consumer to interpret
  // it.
  bytes result_contents = 2;
}
