// Copyright 2023 The Trusted Computations Platform Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package runtime.endpoint;

// Messages coming from the Untrusted Launcher to the Trusted Host.
message InMessage {
  oneof msg {
    // Requests the Trusted Host to start a new Raft replica. Must be the first
    // message sent by the Untrusted Launcher to the Trusted Host.
    StartReplicaRequest start_replica = 1;
    // Requests the Trusted Host to stop an already running Raft replica. Must
    // be the last message sent by the Untrusted Launcher to the Trusted Host.
    StopReplicaRequest stop_replica = 2;
    // Requests the Trusted Host to issue a command to change Raft cluster that
    // is led by the replica.
    ChangeClusterRequest change_cluster = 3;
    // Requests the Trusted Host to report the current state of the Raft
    // cluster, including which replica is the leader, which replicas are in the
    // cluster, are there any pending cluster changes. The latter is important
    // to enable cluster membership changes which must be carried out one at a
    // time.
    CheckClusterRequest check_cluster = 4;
    // Requests the Trusted Host to deliver a Raft message to the replica.
    DeliverMessage deliver_message = 5;
    // Requests the Trusted Host to execute a proposal representing a client
    // action or a query. Note that it is up to the application to interpret and
    // execute that proposal.
    ExecuteProposalRequest execute_proposal = 6;
  }
}

// Messages coming from the Trusted Host to the Untrusted Launcher. The
// Untrusted Launcher is then responsible for delivery of the messages to the
// intended recipients.
message OutMessage {
  oneof msg {
    // Responds to the Untrusted Launcher with the started replica identity and
    // indication status. The generated replica identity will be used to route
    // messages between replicas.
    StartReplicaResponse start_replica = 1;
    // Responds to the Untrsuted Launcher with the stop replica result.
    StopReplicaResponse stop_replica = 2;
    // Requests the Untrusted Launcher to log given message for troubleshooting.
    LogMessage log = 3;
    // Responds to the Untrusted Launcher with the indication if the requested
    // Raft cluster change has been accepted for processing. Note that the
    // actual execution will take time due to replication. The Untrusted
    // Launcher can poll for the result by requesting cluster check.
    ChangeClusterResponse change_cluster = 4;
    // Responds to the Untrusted Launcher with the state of the cluster. The
    // response may be sent because it was explicitly requested or because the
    // internal state of the Raft replica has changed.
    CheckClusterResponse check_cluster = 5;
    // Requests the Untrusted Launcher to deliver the Raft message to a Raft
    // replica hosted in a different Trusted Host.
    DeliverMessage deliver_message = 6;
    // Responds to the Untrusted Launcher with the proposal result in case of
    // success or an error (for example, the replica which received the proposal
    // is not the leader). Note that it may take some time for the Trusted
    // Application to respond to the proposal (the execution of a proposal
    // requires it to be committed to the replicated log). Also it is possible
    // that the replica that has accepted the proposal and the replica that has
    // responded to the proposal are not the same replica due failures.
    ExecuteProposalResponse execute_proposal = 7;
  }
}

// Instructs the trusted application to start by initializing its internal state
// and generating a replica identity for its raft replica. This must be the
// first message sent by the untrusted launcher to the trusted application.
message StartReplicaRequest {
  // Indicates if the new Raft replica to be started as the leader of the Raft
  // cluster.
  bool is_leader = 1;
  // If set is used as the started replica id. Must only be used for testing
  // purposes.
  uint64 replica_id_hint = 2;
}

message StartReplicaResponse {
  // Started replica id, generated by the replica or set to the provided in the
  // request id.
  uint64 replica_id = 1;
}

// Instructs the trusted application to stop the corresponding raft replica.
// This must be the last message sent by the untrusted launcher to the trusted
// application.
message StopReplicaRequest {}

message StopReplicaResponse {}

// Request to log given message for troubleshooting.
message LogMessage {
  // Holds severity of the message.
  LogSeverity severity = 1;
  // Holds message to be logged for troubleshooting.
  string message = 2;
}

enum LogSeverity {
  LOG_SEVERITY_UNSPECIFIED = 0;
  LOG_SEVERITY_INFO = 1;
  LOG_SEVERITY_WARNING = 2;
  LOG_SEVERITY_ERROR = 3;
  LOG_SEVERITY_CRITICAL = 4;
  LOG_SEVERITY_DEBUG = 5;
  LOG_SEVERITY_TRACE = 6;
}

// Request to change the cluster membership such as adding/removing replicas.
message ChangeClusterRequest {
  // Unique id to identify Raft cluster change.
  uint64 change_id = 1;
  // Unique identity of the replica to be added or removed.
  uint64 replica_id = 2;
  // Type of change to be performed i.e. addition or removal of a replica.
  ChangeClusterType change_type = 3;
}

// Response to ChangeClusterRequest.
message ChangeClusterResponse {
  // Unique id associated with ChangeClusterRequest so as to correlate the
  // response with the corresponding request.
  uint64 change_id = 1;
  // Indicates if Raft cluster change has been accepted and pending or rejected.
  ChangeClusterStatus change_status = 2;
}

enum ChangeClusterType {
  CHANGE_TYPE_UNSPECIFIED = 0;
  // Requests to add replica to the Raft cluster.
  CHANGE_TYPE_ADD_REPLICA = 1;
  // Requests to remove replica from the Raft cluster.
  CHANGE_TYPE_REMOVE_REPLICA = 2;
}

enum ChangeClusterStatus {
  CHANGE_STATUS_UNSPECIFIED = 0;
  // Indicates that the Raft cluster change has been accepted for processing.
  CHANGE_STATUS_PENDING = 1;
  // Indicates that the Raft cluster change has been rejected which can be
  // either because the replica is not a leader or there is already a pending
  // cluster change.
  CHANGE_STATUS_REJECTED = 2;
}

// Checks the current state of the Raft cluster.
message CheckClusterRequest {}

// Describes the state of the Raft cluster.
// This can also be issued by the raft cluster leader in the absence of any
// request e.g. if the leadership changes the new leader will send this message
// with its information and the old leader will send an empty
// CheckClusterResponse message indicating that it lost leadership.
message CheckClusterResponse {
  // Holds the id of the Raft replica currently elected leader. Set to 0 if the
  // leader is not known.
  uint64 leader_replica_id = 1;
  // Holds the term of the leader. Set to 0 if leader is not known.
  uint64 leader_term = 2;
  // Holds the set of replica ids that currently belong to the cluster.
  repeated uint64 cluster_replica_ids = 3;
  // Indicates if there are any pending cluster changes.
  bool has_pending_changes = 4;
}

message DeliverMessage {
  // The replica id of the recipient.
  uint64 recipient_replica_id = 1;
  // The replica id of the sender.
  uint64 sender_replica_id = 2;
  // Message to be delivered, potentially encrypted.
  bytes message_contents = 3;
}

message ExecuteProposalRequest {
  // Holds serialized proposal contents. It is up to the Trusted Application to
  // interpret it.
  bytes proposal_contents = 1;
}

message ExecuteProposalResponse {
  // Holds serialized proposal response. It is up to the consumer to interpret
  // it.
  bytes result_contents = 1;
}

service EndpointService {
  // Receives messages to process by the trusted application. Conceptually
  // represents a computation slice.
  // method_id: 1
  rpc ReceiveMessage(ReceiveMessageRequest) returns (ReceiveMessageResponse) {}
}

message ReceiveMessageRequest {
  // A measurement of a monotonically nondecreasing clock provided by
  // the untrusted launcher to the trusted host. The resolution of the instant
  // is measured in milliseconds. Instants are opaque that can only be compared
  // to one another. In other words the absolute value must not be interpreted
  // as wall clock time or time since the trusted application start.
  uint64 instant = 1;

  // A potentially empty message received from the untrusted
  // launcher for the trusted application to process.
  InMessage message = 2;
}

message ReceiveMessageResponse {
  // A potentially empty set of messages that must be sent out to the peers or
  // the consumers.
  repeated OutMessage messages = 1;
}